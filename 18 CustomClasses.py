#### Meta Classes ####

"""
Before understanding metaclasses, you need to master classes in Python. And Python
has a very peculiar idea of what classes are, borrowed from the Smalltalk language.

In most languages, classes are just pieces of code that describe how to produce an
object. That's kinda true in Python too:
"""


class ObjectCreator(object):
    pass


my_object = ObjectCreator()
print("my_object:-", my_object)

"""
But classes are more than that in Python. Classes are objects too.

Yes, objects.

As soon as you use the keyword class, Python executes it and creates an OBJECT.
The instruction

class ObjectCreator(object):
       pass

creates in memory an object with the name "ObjectCreator".

This object (the class) is itself capable of creating objects (the instances), and
this is why it's a class.

But still, it's an object, and therefore:

-you can assign it to a variable
-you can copy it
-you can add attributes to it
-you can pass it as a function parameter
e.g.:
"""

print(ObjectCreator)  # you can print a class because it's an object


def echo(o):
    print(o)


print(hasattr(ObjectCreator, 'new_attribute'))
ObjectCreator.new_attribute = 'foo'  # you can add attributes to a class
print(hasattr(ObjectCreator, 'new_attribute'))
print(ObjectCreator.new_attribute)
ObjectCreatorMirror = ObjectCreator  # you can assign a class to a variable
print(ObjectCreatorMirror.new_attribute)
print(ObjectCreatorMirror())

"""
Creating classes dynamically
Since classes are objects, you can create them on the fly, like any object.

First, you can create a class in a function using class:"""


def choose_class(name):
    if name == 'foo':
        class Foo(object):
            pass

        return Foo  # return the class, not an instance
    else:
        class Bar(object):
            pass

        return Bar


MyClass = choose_class('foo')
print(MyClass)  # the function returns a class, not an instance
print(MyClass())  # you can create an object from this class

"""
But it's not so dynamic, since you still have to write the whole class yourself.

Since classes are objects, they must be generated by something.

When you use the class keyword, Python creates this object automatically. But as
with most things in Python, it gives you a way to do it manually.

Remember the function type? The good old function that lets you know what type an
object is.
Well, type has a completely different ability, it can also create classes on the fly.
 type can take the description of a class as parameters, and return a class.

(I know, it's silly that the same function can have two completely different uses
according to the parameters you pass to it. It's an issue due to backwards
compatibility in Python)

type works this way:
******************************
type(name of the class,
     tuple of the parent class (for inheritance, can be empty),
     dictionary containing attributes names and values)
e.g.:
"""


class MyShinyClass(object):
    pass


#  can be created manually this way:


MyShinyClass = type('MyShinyClass', (), {})      # returns a class object
print(MyShinyClass)
print(MyShinyClass())        # create an instance with the class

"""
You'll notice that we use "MyShinyClass" as the name of the class and as the variable
to hold the class reference. They can be different, but there is no reason to
complicate things.

type accepts a dictionary to define the attributes of the class. So:
"""
class Foo(object):
    bar = True

# Can be translated to:

Foo = type('Foo', (), {'bar':True})

# And used as a normal class:

print(Foo)
print(Foo.bar)
f = Foo()
print(f)
print(f.bar)
# And of course, you can inherit from it, so:

class FooChild(Foo):
       pass


FooChild = type('FooChild', (Foo,), {})
print(FooChild)
print(FooChild.bar) # bar is inherited from Foo

"""Eventually you'll want to add methods to your class. Just define a function with
the proper signature and assign it as an attribute.
"""
def echo_bar(self):
      print(self.bar)

FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
hasattr(Foo, 'echo_bar')
hasattr(FooChild, 'echo_bar')
my_foo = FooChild()
my_foo.echo_bar()

"""
And you can add even more methods after you dynamically create the class, just like
adding methods to a normally created class object.
"""
def echo_bar_more(self):
    print('yet another method')

FooChild.echo_bar_more = echo_bar_more
hasattr(FooChild, 'echo_bar_more')

"""
You see where we are going: in Python, classes are objects, and you can create a
class on the fly, dynamically.

This is what Python does when you use the keyword class, and it does so by using
a metaclass.
"""

"""
Metaclasses are an esoteric OOP concept, lurking behind virtually all Python code. 
You are using them
whether you are aware of it or not. For the most part, you donâ€™t need to be aware 
of it. Most Python
programmers rarely, if ever, have to think about metaclasses.


Remember that, in Python, everything is an object. Classes are objects as well. As a 
result, a class must have a type.
What is the type of a class?


class Foo:
   pass

x = Foo()

type(x)
# <class '__main__.Foo'>

type(Foo)
# <class 'type'>
The type of x is class Foo, as you would expect. But the type of Foo, the class 
itself, is type.
In general, the type of any class is type.

The type of the built-in classes you are familiar with is also type:

for t in int, float, dict, list, tuple:
    print(type(t))

# <class 'type'>
# <class 'type'>
# <class 'type'>
# <class 'type'>
# <class 'type'>
For that matter, the type of type is type as well (yes, really):

type(type)
# <class 'type'>
type is a metaclass, of which classes are instances. Just as an ordinary object 
is an instance of a class,
any class in Python, and thus any class in Python 3, is an instance of the type 
metaclass.

In the above case:

x is an instance of class Foo.
Foo is an instance of the type metaclass.
type is also an instance of the type metaclass, so it is an instance of itself.

"""

#### Create class ####

class_name = "TestClass"
class_parents = (object,)
class_attr = {}
class_body = """
def __init__(self, new_n):
    if type(new_n)!= int:
        raise TypeError("Bad Arguments")
    self.n = new_n
    
def get_n(self):
    return self.n
    
def set_n(self, new_n):
    if type(new_n)!= int:
        raise TypeError("Bad Arguments")
    self.n = new_n
"""
exec(class_body, globals(), class_attr)

for attr in class_attr:
    print(attr, type(attr), class_attr[attr])

TestClass = type(class_name, class_parents, class_attr)

inc = TestClass(100)
print(inc.get_n())
inc.set_n(200)
print(inc.get_n())

print("-----------------Assignment-----------------------")

class_name = "Test"
class_parents = (object,)
class_attr = {}
class_body = """
def __init__(self, n_msg):
    if type(n_msg)!= str:
        raise TypeError("Bad Arguments")
    self.msg = n_msg

def get_n(self):
    return self.msg
    
def set_n(self, n_msg):
    if type(n_msg)!= str:
        raise TypeError("Bad Arguments")
    self.msg = n_msg

data_attr = 100

def test_static():
    print("In static method")
"""
exec(class_body, globals(), class_attr)
for attr in class_attr:
    print(attr, type(attr), class_attr[attr])

Test = type(class_name, class_parents, class_attr)

t = Test("Hello")
print(t.get_n())
t.set_n("World")
print(t.get_n())
print(t.data_attr)
Test.test_static()
print(Test.data_attr, "==", t.data_attr)
